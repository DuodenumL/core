// Code generated by mockery 2.9.0. DO NOT EDIT.

package mocks

import (
	context "context"

	mock "github.com/stretchr/testify/mock"

	resourcestypes "github.com/projecteru2/core/resources/types"

	types "github.com/projecteru2/core/types"
)

// Plugin is an autogenerated mock type for the Plugin type
type Plugin struct {
	mock.Mock
}

// AddNode provides a mock function with given fields: ctx, node, rawRequest
func (_m *Plugin) AddNode(ctx context.Context, node string, rawRequest types.RawParams) (types.RawParams, types.RawParams, error) {
	ret := _m.Called(ctx, node, rawRequest)

	var r0 types.RawParams
	if rf, ok := ret.Get(0).(func(context.Context, string, types.RawParams) types.RawParams); ok {
		r0 = rf(ctx, node, rawRequest)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(types.RawParams)
		}
	}

	var r1 types.RawParams
	if rf, ok := ret.Get(1).(func(context.Context, string, types.RawParams) types.RawParams); ok {
		r1 = rf(ctx, node, rawRequest)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(types.RawParams)
		}
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(context.Context, string, types.RawParams) error); ok {
		r2 = rf(ctx, node, rawRequest)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// Alloc provides a mock function with given fields: ctx, node, deployCount, rawRequest
func (_m *Plugin) Alloc(ctx context.Context, node string, deployCount int, rawRequest types.RawParams) ([]types.RawParams, []types.RawParams, error) {
	ret := _m.Called(ctx, node, deployCount, rawRequest)

	var r0 []types.RawParams
	if rf, ok := ret.Get(0).(func(context.Context, string, int, types.RawParams) []types.RawParams); ok {
		r0 = rf(ctx, node, deployCount, rawRequest)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]types.RawParams)
		}
	}

	var r1 []types.RawParams
	if rf, ok := ret.Get(1).(func(context.Context, string, int, types.RawParams) []types.RawParams); ok {
		r1 = rf(ctx, node, deployCount, rawRequest)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).([]types.RawParams)
		}
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(context.Context, string, int, types.RawParams) error); ok {
		r2 = rf(ctx, node, deployCount, rawRequest)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// Diff provides a mock function with given fields: ctx, srcResourceArgs, dstResourceArgs
func (_m *Plugin) Diff(ctx context.Context, srcResourceArgs types.RawParams, dstResourceArgs types.RawParams) (types.RawParams, error) {
	ret := _m.Called(ctx, srcResourceArgs, dstResourceArgs)

	var r0 types.RawParams
	if rf, ok := ret.Get(0).(func(context.Context, types.RawParams, types.RawParams) types.RawParams); ok {
		r0 = rf(ctx, srcResourceArgs, dstResourceArgs)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(types.RawParams)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, types.RawParams, types.RawParams) error); ok {
		r1 = rf(ctx, srcResourceArgs, dstResourceArgs)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetNodeResourceInfo provides a mock function with given fields: ctx, node, workloads, fix
func (_m *Plugin) GetNodeResourceInfo(ctx context.Context, node string, workloads []*types.Workload, fix bool) (types.RawParams, types.RawParams, []string, error) {
	ret := _m.Called(ctx, node, workloads, fix)

	var r0 types.RawParams
	if rf, ok := ret.Get(0).(func(context.Context, string, []*types.Workload, bool) types.RawParams); ok {
		r0 = rf(ctx, node, workloads, fix)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(types.RawParams)
		}
	}

	var r1 types.RawParams
	if rf, ok := ret.Get(1).(func(context.Context, string, []*types.Workload, bool) types.RawParams); ok {
		r1 = rf(ctx, node, workloads, fix)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(types.RawParams)
		}
	}

	var r2 []string
	if rf, ok := ret.Get(2).(func(context.Context, string, []*types.Workload, bool) []string); ok {
		r2 = rf(ctx, node, workloads, fix)
	} else {
		if ret.Get(2) != nil {
			r2 = ret.Get(2).([]string)
		}
	}

	var r3 error
	if rf, ok := ret.Get(3).(func(context.Context, string, []*types.Workload, bool) error); ok {
		r3 = rf(ctx, node, workloads, fix)
	} else {
		r3 = ret.Error(3)
	}

	return r0, r1, r2, r3
}

// LockNodes provides a mock function with given fields: ctx, nodes
func (_m *Plugin) LockNodes(ctx context.Context, nodes []string) error {
	ret := _m.Called(ctx, nodes)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, []string) error); ok {
		r0 = rf(ctx, nodes)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Name provides a mock function with given fields:
func (_m *Plugin) Name() string {
	ret := _m.Called()

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// Realloc provides a mock function with given fields: ctx, workloads, resourceOpts
func (_m *Plugin) Realloc(ctx context.Context, workloads []*types.Workload, resourceOpts types.RawParams) (map[string]types.RawParams, map[string]types.RawParams, error) {
	ret := _m.Called(ctx, workloads, resourceOpts)

	var r0 map[string]types.RawParams
	if rf, ok := ret.Get(0).(func(context.Context, []*types.Workload, types.RawParams) map[string]types.RawParams); ok {
		r0 = rf(ctx, workloads, resourceOpts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string]types.RawParams)
		}
	}

	var r1 map[string]types.RawParams
	if rf, ok := ret.Get(1).(func(context.Context, []*types.Workload, types.RawParams) map[string]types.RawParams); ok {
		r1 = rf(ctx, workloads, resourceOpts)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(map[string]types.RawParams)
		}
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(context.Context, []*types.Workload, types.RawParams) error); ok {
		r2 = rf(ctx, workloads, resourceOpts)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// Remap provides a mock function with given fields: ctx, node, workloadMap
func (_m *Plugin) Remap(ctx context.Context, node string, workloadMap map[string]*types.Workload) (map[string]types.RawParams, error) {
	ret := _m.Called(ctx, node, workloadMap)

	var r0 map[string]types.RawParams
	if rf, ok := ret.Get(0).(func(context.Context, string, map[string]*types.Workload) map[string]types.RawParams); ok {
		r0 = rf(ctx, node, workloadMap)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string]types.RawParams)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, map[string]*types.Workload) error); ok {
		r1 = rf(ctx, node, workloadMap)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RemoveNode provides a mock function with given fields: ctx, node
func (_m *Plugin) RemoveNode(ctx context.Context, node string) error {
	ret := _m.Called(ctx, node)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = rf(ctx, node)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SelectAvailableNodes provides a mock function with given fields: ctx, nodes, requestOpts
func (_m *Plugin) SelectAvailableNodes(ctx context.Context, nodes []string, requestOpts types.RawParams) (map[string]*resourcestypes.NodeResourceInfo, int, error) {
	ret := _m.Called(ctx, nodes, requestOpts)

	var r0 map[string]*resourcestypes.NodeResourceInfo
	if rf, ok := ret.Get(0).(func(context.Context, []string, types.RawParams) map[string]*resourcestypes.NodeResourceInfo); ok {
		r0 = rf(ctx, nodes, requestOpts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string]*resourcestypes.NodeResourceInfo)
		}
	}

	var r1 int
	if rf, ok := ret.Get(1).(func(context.Context, []string, types.RawParams) int); ok {
		r1 = rf(ctx, nodes, requestOpts)
	} else {
		r1 = ret.Get(1).(int)
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(context.Context, []string, types.RawParams) error); ok {
		r2 = rf(ctx, nodes, requestOpts)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// SetNodeResourceInfo provides a mock function with given fields: ctx, resourceCapacity, resourceUsage
func (_m *Plugin) SetNodeResourceInfo(ctx context.Context, resourceCapacity types.RawParams, resourceUsage types.RawParams) error {
	ret := _m.Called(ctx, resourceCapacity, resourceUsage)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, types.RawParams, types.RawParams) error); ok {
		r0 = rf(ctx, resourceCapacity, resourceUsage)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UnlockNodes provides a mock function with given fields: ctx, nodes
func (_m *Plugin) UnlockNodes(ctx context.Context, nodes []string) error {
	ret := _m.Called(ctx, nodes)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, []string) error); ok {
		r0 = rf(ctx, nodes)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpdateNodeResourceCapacity provides a mock function with given fields: ctx, node, resourceOpts, direction
func (_m *Plugin) UpdateNodeResourceCapacity(ctx context.Context, node string, resourceOpts types.RawParams, direction bool) error {
	ret := _m.Called(ctx, node, resourceOpts, direction)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, types.RawParams, bool) error); ok {
		r0 = rf(ctx, node, resourceOpts, direction)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpdateNodeResourceUsage provides a mock function with given fields: ctx, node, resourceArgs, direction
func (_m *Plugin) UpdateNodeResourceUsage(ctx context.Context, node string, resourceArgs []types.RawParams, direction bool) error {
	ret := _m.Called(ctx, node, resourceArgs, direction)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, []types.RawParams, bool) error); ok {
		r0 = rf(ctx, node, resourceArgs, direction)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}
