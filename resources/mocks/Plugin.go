// Code generated by mockery 2.9.0. DO NOT EDIT.

package mocks

import (
	context "context"

	resources "github.com/projecteru2/core/resources"
	mock "github.com/stretchr/testify/mock"

	resourcestypes "github.com/projecteru2/core/resources/types"

	types "github.com/projecteru2/core/types"
)

// Plugin is an autogenerated mock type for the Plugin type
type Plugin struct {
	mock.Mock
}

// Alloc provides a mock function with given fields: ctx, node, deployCount, rawRequest
func (_m *Plugin) Alloc(ctx context.Context, node string, deployCount int, rawRequest resources.RawParams) ([]resources.RawParams, []resources.RawParams, error) {
	ret := _m.Called(ctx, node, deployCount, rawRequest)

	var r0 []resources.RawParams
	if rf, ok := ret.Get(0).(func(context.Context, string, int, resources.RawParams) []resources.RawParams); ok {
		r0 = rf(ctx, node, deployCount, rawRequest)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]resources.RawParams)
		}
	}

	var r1 []resources.RawParams
	if rf, ok := ret.Get(1).(func(context.Context, string, int, resources.RawParams) []resources.RawParams); ok {
		r1 = rf(ctx, node, deployCount, rawRequest)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).([]resources.RawParams)
		}
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(context.Context, string, int, resources.RawParams) error); ok {
		r2 = rf(ctx, node, deployCount, rawRequest)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GetNodeResource provides a mock function with given fields: ctx, node, workloads, fix
func (_m *Plugin) GetNodeResource(ctx context.Context, node string, workloads []*types.Workload, fix bool) (resources.RawParams, []string, error) {
	ret := _m.Called(ctx, node, workloads, fix)

	var r0 resources.RawParams
	if rf, ok := ret.Get(0).(func(context.Context, string, []*types.Workload, bool) resources.RawParams); ok {
		r0 = rf(ctx, node, workloads, fix)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(resources.RawParams)
		}
	}

	var r1 []string
	if rf, ok := ret.Get(1).(func(context.Context, string, []*types.Workload, bool) []string); ok {
		r1 = rf(ctx, node, workloads, fix)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).([]string)
		}
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(context.Context, string, []*types.Workload, bool) error); ok {
		r2 = rf(ctx, node, workloads, fix)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// LockNodes provides a mock function with given fields: ctx, nodes
func (_m *Plugin) LockNodes(ctx context.Context, nodes []string) error {
	ret := _m.Called(ctx, nodes)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, []string) error); ok {
		r0 = rf(ctx, nodes)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Name provides a mock function with given fields:
func (_m *Plugin) Name() string {
	ret := _m.Called()

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// Realloc provides a mock function with given fields: ctx, workloads, resourceOpts
func (_m *Plugin) Realloc(ctx context.Context, workloads []*types.Workload, resourceOpts resources.RawParams) (map[string]resources.RawParams, map[string]resources.RawParams, error) {
	ret := _m.Called(ctx, workloads, resourceOpts)

	var r0 map[string]resources.RawParams
	if rf, ok := ret.Get(0).(func(context.Context, []*types.Workload, resources.RawParams) map[string]resources.RawParams); ok {
		r0 = rf(ctx, workloads, resourceOpts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string]resources.RawParams)
		}
	}

	var r1 map[string]resources.RawParams
	if rf, ok := ret.Get(1).(func(context.Context, []*types.Workload, resources.RawParams) map[string]resources.RawParams); ok {
		r1 = rf(ctx, workloads, resourceOpts)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(map[string]resources.RawParams)
		}
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(context.Context, []*types.Workload, resources.RawParams) error); ok {
		r2 = rf(ctx, workloads, resourceOpts)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// Remap provides a mock function with given fields: ctx, node, workloadMap
func (_m *Plugin) Remap(ctx context.Context, node string, workloadMap map[string]*types.Workload) (map[string]resources.RawParams, error) {
	ret := _m.Called(ctx, node, workloadMap)

	var r0 map[string]resources.RawParams
	if rf, ok := ret.Get(0).(func(context.Context, string, map[string]*types.Workload) map[string]resources.RawParams); ok {
		r0 = rf(ctx, node, workloadMap)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string]resources.RawParams)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, map[string]*types.Workload) error); ok {
		r1 = rf(ctx, node, workloadMap)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RemoveNode provides a mock function with given fields: ctx, node
func (_m *Plugin) RemoveNode(ctx context.Context, node string) error {
	ret := _m.Called(ctx, node)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = rf(ctx, node)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SelectAvailableNodes provides a mock function with given fields: ctx, nodes, requestOpts
func (_m *Plugin) SelectAvailableNodes(ctx context.Context, nodes []string, requestOpts resources.RawParams) (map[string]*resourcestypes.NodeResourceInfo, int, error) {
	ret := _m.Called(ctx, nodes, requestOpts)

	var r0 map[string]*resourcestypes.NodeResourceInfo
	if rf, ok := ret.Get(0).(func(context.Context, []string, resources.RawParams) map[string]*resourcestypes.NodeResourceInfo); ok {
		r0 = rf(ctx, nodes, requestOpts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string]*resourcestypes.NodeResourceInfo)
		}
	}

	var r1 int
	if rf, ok := ret.Get(1).(func(context.Context, []string, resources.RawParams) int); ok {
		r1 = rf(ctx, nodes, requestOpts)
	} else {
		r1 = ret.Get(1).(int)
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(context.Context, []string, resources.RawParams) error); ok {
		r2 = rf(ctx, nodes, requestOpts)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// SetNodeResource provides a mock function with given fields: ctx, node, rawRequest
func (_m *Plugin) SetNodeResource(ctx context.Context, node string, rawRequest resources.RawParams) error {
	ret := _m.Called(ctx, node, rawRequest)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, resources.RawParams) error); ok {
		r0 = rf(ctx, node, rawRequest)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UnlockNodes provides a mock function with given fields: ctx, nodes
func (_m *Plugin) UnlockNodes(ctx context.Context, nodes []string) error {
	ret := _m.Called(ctx, nodes)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, []string) error); ok {
		r0 = rf(ctx, nodes)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpdateNodeResource provides a mock function with given fields: ctx, node, resourceArgs, direction
func (_m *Plugin) UpdateNodeResource(ctx context.Context, node string, resourceArgs []resources.RawParams, direction bool) error {
	ret := _m.Called(ctx, node, resourceArgs, direction)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, []resources.RawParams, bool) error); ok {
		r0 = rf(ctx, node, resourceArgs, direction)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}
